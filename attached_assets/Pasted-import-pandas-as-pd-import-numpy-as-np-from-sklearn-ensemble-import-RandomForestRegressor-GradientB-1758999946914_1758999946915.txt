import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.metrics import mean_absolute_error, r2_score, mean_squared_error
from sklearn.preprocessing import LabelEncoder
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

class IPLScorePredictor:
    def _init_(self):
        self.model = RandomForestRegressor(n_estimators=200, max_depth=15, random_state=42)
        self.label_encoders = {}
        self.team_stats = {}
        self.venue_stats = {}
        self.is_trained = False
        
    def create_comprehensive_dataset(self, n_matches=2000):
        """Create comprehensive IPL dataset with realistic match scenarios"""
        np.random.seed(42)
        
        # IPL Teams (current and past)
        df=pd.read_csv(r"C:\Users\aditi\OneDrive\Desktop\Excel\ipl_2023_dataset.csv")
        data = []
        
        # Generate matches for multiple seasons
        for season in range(2020, 2025):
            season_matches = n_matches // 5
            
            for match_id in range(season_matches):
                # Select teams
                batting_team = np.random.choice(df)
                bowling_team = np.random.choice([t for t in df if t != batting_team])
                venue_name = np.random.choice(list(df.keys()))
                venue_info =df[venue_name]
                
                # Match details
                innings = np.random.choice([1, 2], p=[0.5, 0.5])
                match_type = np.random.choice(['League', 'Qualifier', 'Eliminator', 'Final'], 
                                            p=[0.85, 0.08, 0.04, 0.03])
                
                # Conditions
                weather = np.random.choice(['Clear', 'Overcast', 'Humid', 'Windy'], 
                                         p=[0.5, 0.25, 0.15, 0.1])
                pitch_type = venue_info['type']
                
                # Time of match
                day_night = np.random.choice(['Day', 'Day-Night', 'Night'], p=[0.2, 0.3, 0.5])
                
                # Toss
                toss_winner = np.random.choice([batting_team, bowling_team])
                if toss_winner == batting_team:
                    toss_decision = 'Bat'
                else:
                    toss_decision = np.random.choice(['Bat', 'Bowl'], p=[0.3, 0.7])
                
                # Calculate expected score based on multiple factors
                base_score = venue_info['avg_score']
                
                # Team strength impact
                bat_strength = df[batting_team]['batting_strength']
                bowl_strength = df[bowling_team]['bowling_strength']
                
                team_factor = (bat_strength - bowl_strength + 10) / 10
                base_score *= team_factor
                
                # Venue type impact
                if pitch_type == 'batting_friendly':
                    base_score *= np.random.uniform(1.05, 1.15)
                elif pitch_type == 'bowling_friendly':
                    base_score *= np.random.uniform(0.85, 0.95)
                else:  # balanced
                    base_score *= np.random.uniform(0.95, 1.05)
                
                # Weather impact
                weather_multiplier = {
                    'Clear': np.random.uniform(1.0, 1.02),
                    'Overcast': np.random.uniform(0.92, 0.98),
                    'Humid': np.random.uniform(0.88, 0.95),
                    'Windy': np.random.uniform(0.95, 1.05)
                }
                base_score *= weather_multiplier[weather]
                
                # Day/Night impact
                if day_night == 'Night':
                    base_score *= np.random.uniform(0.98, 1.02)
                elif day_night == 'Day-Night':
                    base_score *= np.random.uniform(1.02, 1.06)
                
                # Innings impact
                if innings == 2:
                    # Second innings might be affected by target pressure
                    base_score *= np.random.uniform(0.92, 1.08)
                
                # Match importance impact
                importance_multiplier = {
                    'League': 1.0,
                    'Qualifier': 0.95,  # More cautious
                    'Eliminator': 0.92,
                    'Final': 0.90
                }
                base_score *= importance_multiplier[match_type]
                
                # Add randomness and ensure realistic bounds
                final_score = int(base_score + np.random.normal(0, 12))
                final_score = max(70, min(265, final_score))
                
                # Calculate other match statistics
                # Wickets lost (inversely correlated with score)
                if final_score >= 200:
                    wickets = np.random.choice(range(2, 7), p=[0.3, 0.25, 0.2, 0.15, 0.1])
                elif final_score >= 160:
                    wickets = np.random.choice(range(3, 8), p=[0.2, 0.25, 0.25, 0.2, 0.1])
                elif final_score >= 120:
                    wickets = np.random.choice(range(4, 9), p=[0.15, 0.2, 0.25, 0.25, 0.15])
                else:
                    wickets = np.random.choice(range(6, 11), p=[0.2, 0.25, 0.25, 0.2, 0.1])
                
                # Overs faced
                if wickets == 10:
                    overs = round(np.random.uniform(10.0, 19.6), 1)
                else:
                    overs = 20.0
                
                # Calculate run rate
                run_rate = final_score / overs
                
                # Calculate boundaries (4s and 6s)
                boundary_rate = final_score / 180  # Normalized boundary rate
                fours = int(np.random.poisson(boundary_rate * 12))
                sixes = int(np.random.poisson(boundary_rate * 6))
                
                # Powerplay score (first 6 overs)
                pp_multiplier = np.random.uniform(0.8, 1.3)
                powerplay_score = int((final_score * 6 / 20) * pp_multiplier)
                powerplay_score = min(powerplay_score, final_score - 20)
                
                # Death overs score (last 4 overs)
                death_multiplier = np.random.uniform(1.1, 1.8)
                death_overs_score = int((final_score * 4 / 20) * death_multiplier)
                death_overs_score = min(death_overs_score, final_score - powerplay_score)
                
                data.append({
                    'season': season,
                    'match_id': f"{season}_{match_id}",
                    'batting_team': batting_team,
                    'bowling_team': bowling_team,
                    'venue': venue_name,
                    'venue_type': pitch_type,
                    'innings': innings,
                    'weather': weather,
                    'day_night': day_night,
                    'match_type': match_type,
                    'toss_winner': toss_winner,
                    'toss_decision': toss_decision,
                    'batting_team_strength': bat_strength,
                    'bowling_team_strength': bowl_strength,
                    'overs': overs,
                    'wickets': wickets,
                    'total_score': final_score,
                    'run_rate': run_rate,
                    'fours': fours,
                    'sixes': sixes,
                    'powerplay_score': powerplay_score,
                    'death_overs_score': death_overs_score
                })
        
        return pd.DataFrame(data)
    
    def prepare_features(self, df):
        """Prepare features for machine learning"""
        df_processed = df.copy()
        
        # Encode categorical variables
        categorical_cols = ['batting_team', 'bowling_team', 'venue', 'venue_type', 
                          'weather', 'day_night', 'match_type', 'toss_winner', 'toss_decision']
        
        for col in categorical_cols:
            if col not in self.label_encoders:
                self.label_encoders[col] = LabelEncoder()
                df_processed[col] = self.label_encoders[col].fit_transform(df_processed[col])
            else:
                df_processed[col] = self.label_encoders[col].transform(df_processed[col])
        
        # Create additional features
        df_processed['team_strength_diff'] = df_processed['batting_team_strength'] - df_processed['bowling_team_strength']
        df_processed['toss_advantage'] = (df_processed['toss_winner'] == df_processed['batting_team']).astype(int)
        
        return df_processed
    
    def train_model(self, df):
        """Train the prediction model"""
        df_processed = self.prepare_features(df)
        
        # Select features
        feature_cols = ['batting_team', 'bowling_team', 'venue', 'venue_type', 'innings',
                       'weather', 'day_night', 'match_type', 'toss_decision', 
                       'batting_team_strength', 'bowling_team_strength', 'team_strength_diff',
                       'toss_advantage', 'overs', 'wickets']
        
        X = df_processed[feature_cols]
        y = df_processed['total_score']
        
        # Split the data
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
        
        # Train the model
        self.model.fit(X_train, y_train)
        
        # Evaluate the model
        train_pred = self.model.predict(X_train)
        test_pred = self.model.predict(X_test)
        
        print("=== Model Performance ===")
        print(f"Training MAE: {mean_absolute_error(y_train, train_pred):.2f}")
        print(f"Testing MAE: {mean_absolute_error(y_test, test_pred):.2f}")
        print(f"Training RÂ²: {r2_score(y_train, train_pred):.3f}")
        print(f"Testing RÂ²: {r2_score(y_test, test_pred):.3f}")
        print(f"Training RMSE: {np.sqrt(mean_squared_error(y_train, train_pred)):.2f}")
        print(f"Testing RMSE: {np.sqrt(mean_squared_error(y_test, test_pred)):.2f}")
        
        # Cross-validation
        cv_scores = cross_val_score(self.model, X, y, cv=5, scoring='neg_mean_absolute_error')
        print(f"Cross-validation MAE: {-cv_scores.mean():.2f} (+/- {cv_scores.std() * 2:.2f})")
        
        self.is_trained = True
        self.feature_cols = feature_cols
        
        return X_test, y_test, test_pred
    
    def predict_score(self, batting_team, bowling_team, venue, innings=1, weather='Clear',
                     day_night='Night', match_type='League', toss_winner=None, 
                     toss_decision='Bat', overs=20.0, wickets=3):
        """Predict score for given match conditions"""
        if not self.is_trained:
            raise ValueError("Model not trained yet. Call train_model() first.")
        
        # Create input dataframe
        input_data = pd.DataFrame({
            'batting_team': [batting_team],
            'bowling_team': [bowling_team],
            'venue': [venue],
            'venue_type': ['batting_friendly'],  # Default
            'innings': [innings],
            'weather': [weather],
            'day_night': [day_night],
            'match_type': [match_type],
            'toss_winner': [toss_winner or batting_team],
            'toss_decision': [toss_decision],
            'batting_team_strength': [8.0],  # Default
            'bowling_team_strength': [8.0],  # Default
            'overs': [overs],
            'wickets': [wickets]
        })
        
        # Process features
        processed_data = self.prepare_features(input_data)
        processed_data['team_strength_diff'] = processed_data['batting_team_strength'] - processed_data['bowling_team_strength']
        processed_data['toss_advantage'] = (processed_data['toss_winner'] == processed_data['batting_team']).astype(int)
        
        # Make prediction
        prediction = self.model.predict(processed_data[self.feature_cols])
        
        return int(prediction[0])
    
    def analyze_feature_importance(self):
        """Analyze feature importance"""
        if not self.is_trained:
            raise ValueError("Model not trained yet.")
        
        importance_df = pd.DataFrame({
            'feature': self.feature_cols,
            'importance': self.model.feature_importances_
        }).sort_values('importance', ascending=False)
        
        plt.figure(figsize=(10, 6))
        sns.barplot(data=importance_df.head(10), x='importance', y='feature')
        plt.title('Top 10 Feature Importance for Score Prediction')
        plt.xlabel('Importance')
        plt.tight_layout()
        plt.show()
        
        return importance_df
    
    def visualize_predictions(self, X_test, y_test, test_pred):
        """Visualize model predictions"""
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        
        # Actual vs Predicted
        axes[0, 0].scatter(y_test, test_pred, alpha=0.6)
        axes[0, 0].plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--', lw=2)
        axes[0, 0].set_xlabel('Actual Score')
        axes[0, 0].set_ylabel('Predicted Score')
        axes[0, 0].set_title('Actual vs Predicted Scores')
        
        # Residual plot
        residuals = y_test - test_pred
        axes[0, 1].scatter(test_pred, residuals, alpha=0.6)
        axes[0, 1].axhline(y=0, color='r', linestyle='--')
        axes[0, 1].set_xlabel('Predicted Score')
        axes[0, 1].set_ylabel('Residuals')
        axes[0, 1].set_title('Residual Plot')
        
        # Distribution of actual scores
        axes[1, 0].hist(y_test, bins=30, alpha=0.7, label='Actual')
        axes[1, 0].hist(test_pred, bins=30, alpha=0.7, label='Predicted')
        axes[1, 0].set_xlabel('Score')
        axes[1, 0].set_ylabel('Frequency')
        axes[1, 0].set_title('Score Distribution')
        axes[1, 0].legend()
        
        # Error distribution
        axes[1, 1].hist(residuals, bins=30, alpha=0.7)
        axes[1, 1].set_xlabel('Prediction Error')
        axes[1, 1].set_ylabel('Frequency')
        axes[1, 1].set_title('Prediction Error Distribution')
        
        plt.tight_layout()
        plt.show()

# Example usage
if _name_ == "_main_":
    # Initialize predictor
    predictor = IPLScorePredictor()
    
    # Create dataset
    print("Creating IPL dataset...")
    df = predictor.create_comprehensive_dataset(n_matches=2000)
    print(f"Dataset created with {len(df)} matches")
    print("\nDataset Info:")
    print(df.info())
    print("\nSample data:")
    print(df.head())
    
    # Display dataset statistics
    print("\n=== Dataset Statistics ===")
    print(f"Average Score: {df['total_score'].mean():.1f}")
    print(f"Score Range: {df['total_score'].min()} - {df['total_score'].max()}")
    print(f"Standard Deviation: {df['total_score'].std():.1f}")
    
    print("\nTeam-wise average scores:")
    team_avg = df.groupby('batting_team')['total_score'].mean().sort_values(ascending=False)
    print(team_avg)
    
    print("\nVenue-wise average scores:")
    venue_avg = df.groupby('venue')['total_score'].mean().sort_values(ascending=False)
    print(venue_avg.head())
    
    # Train model
    print("\n=== Training Model ===")
    X_test, y_test, test_pred = predictor.train_model(df)
    
    # Analyze feature importance
    print("\n=== Feature Importance ===")
    importance_df = predictor.analyze_feature_importance()
    print(importance_df.head(10))
    
    # Visualize results
    predictor.visualize_predictions(X_test, y_test, test_pred)
    
    # Example predictions
    print("\n=== Example Predictions ===")
    
    # Example 1: MI vs CSK at Wankhede
    prediction1 = predictor.predict_score(
        batting_team='MI', 
        bowling_team='CSK', 
        venue='Wankhede Stadium, Mumbai',
        weather='Clear',
        day_night='Night'
    )
    print(f"MI vs CSK at Wankhede (Night): {prediction1} runs")
    
    # Example 2: RCB vs KKR at Chinnaswamy
    prediction2 = predictor.predict_score(
        batting_team='RCB', 
        bowling_team='KKR', 
        venue='M. Chinnaswamy Stadium, Bangalore',
        weather='Clear',
        day_night='Night'
    )
    print(f"RCB vs KKR at Chinnaswamy (Night): {prediction2} runs")
    
    # Example 3: CSK vs SRH at Chennai
    prediction3 = predictor.predict_score(
        batting_team='CSK', 
        bowling_team='SRH', 
        venue='MA Chidambaram Stadium, Chennai',
        weather='Humid',
        day_night='Day-Night'
    )
    print(f"CSK vs SRH at Chennai (Day-Night, Humid): {prediction3} runs")
    
    print("\n=== Model Training Complete ===")
    print("You can now use predictor.predict_score() for new predictions!")